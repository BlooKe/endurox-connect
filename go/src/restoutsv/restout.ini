[@restout]
gencore=1
workers=<Number outgoing threads>
#
# Defaults: conv=json2ubf
# async - call service in async way, if submitted ok, just reply back with ok
#
# Hmm we could use same format for definding defaults...
defaults={"urlbase":"http://silodev.com"
	   "errors":"http"
        ,"reqlogsvc": "GETFILE"
        ,"noreqfilersp": true
        }

service <XATMI Service>={
	# This will be converted to "urlbase" from default to urlbase+url if starts with /
	# ie. http://silodev.com/func1
	# ----
	# If it will not start with /, then assume it is full URL.
	"url":"/func1",

	# Error handling modes:
	"errors":"http",
	# Allow only two codes 13 (tout), 11 (error) or 0 (succeed), in case of http errors
	"errors_fmt_http_map":"404:11,200:0,*:11",

	########################################################################
	# "errors":"json"
	# in this case we will use
	# ,"errfmt_json_code":"\"error_code1\""
	# ,"errfmt_json_msg":"\"error_message1\""
	# will use these fields as error transport.
	# Also, the error mapping will downgraded to 0 - ok, 11 - fail, for any
	# error. This will be hardcoded.
	# If using JSON errors, then use errfmt_json_onsucc flag too.
	# so that if flag is *false* and there is no error fields in json block
	# then assume that response is ok.
	########################################################################


	########################################################################
	# "errors":"text"
	# in this case we will use regexp
	# ,"errfmt_text":"(.*): (.*))"
	# So when we get an response, we will try to parse the output
	# if parsed ok, then use standard error mapping 0, 11 - fail, any other
	# fail.
	# If did not parse ok the message, assume that response was ok.
	# this is effective in case if http error is ok. If there is http fail
	# then it is failure anyway.
	########################################################################


	########################################################################
	# "errors":"json2ubf"
	# In this case standard fields like EX_IF_ECODE and EX_IF_EMSG will
	# be used. We shall add new paramter 'errfmt_json2ubf_leave" - this if
	# set to *true*
	# will leave the error code & message in buffer so that caller can do
	# further analysis of the response code.
	########################################################################

	#
	# We do not need "conv" as it will use the incoming buffer as the format
	# for data delivery
	#


	# "async", if set to *true* will submit the message to outgoing channel
	# and do reply immediately.

	########################################################################
	# "echo" - true - send echos
	# "echo_time" - every X seconds
	# "echo_max_fail" - max number of fails to unadvertises services at deps
	# "echo_min_ok" - min number of echos ok to advertise deps
	########################################################################


	########################################################################
	# "depend_on" - Service name on which we depend for echo.
	# once all services are parsed in, all services must be added to hash
	# list.
	# for "depend_on" we search for service which must be echo.
	# - if it is not echo, then startup is failed
	# - if found, then add to internal list of services which depend on
	# - and these services become managed by echo service
	# other servces must be advertise ad the startup (which does not
	# depend on echo service)
	########################################################################


	########################################################################
	# "timeout" - timeout, number of seconds to wait for HTTP server to respond
	# to our client.
	########################################################################

	########################################################################
	# "noreqfilereq" - Do not send request file name
	# to the target service in JSON2UBF request message
	########################################################################

	}
# Enduro/X debug string setup
debug = <Enduro/X debug string>
