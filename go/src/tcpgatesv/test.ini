#
# EX_GATEWAY =  TCP_SYSTEM1
# EX_GATEWAY_ID = 1...N (the connection id at gateway)
# EX_GATEWAY_CORR = Message correlator (for persistent links)
# EX_GATEWAY_RSPSVC = Response service for collerators (if set, then not server contexts will be suspended)
# At response: EX_NERROR_CODE, EX_NERROR_MSG - if any error.
# EX_BUFFER - buffer for request, and for response.
#
[@tcpgate]

workers_out = 10
workers_in = 10

#
# Service for outgoing connections (Gateway name, effectively service name)
#
gateway=TCP_SYSTEM1

#
# l - little endian
# L - big endian
# n - no framing, just process packets as received & sent.
framing=llllll...l|LLLLLL ... L|d|

# if framing = d
#  delim_start - optional
delim_start = 0x02
delim_sop = 0x03
#A - Active
#P - Passive
type=A|P
ip=0.0.0.0
port=5555

#
# Service to sending incoming messages (service will receive EX_BUFFER, EX_GATEWAY, EX_GATEWAY_ID)
#
incoming_service=<target_Service>

#
# Enduro/X standard debug string:
# we need new config flags for dumping, Y -enable dumps, N - no dumps please (for PCI/DSS)
#
debug= ndrx=5 user=5 ubf=1 file=${NDRX_APPDIR}/tmp/TCP_SYSTEM1 dumps=Y|N

#
# Number of seconds to send zero length message (0 disabled, or if not set disable too):
#
periozero=5
statussvc=<Send_status_to_service>

#
# max number of incoming persistent connections
# if in passive mode, then max connections server must keep active
#
max_connection=5

#
# Active: In this mode we make signle request & reply, and then we close connection
# Passive: We recieve request process, do respond, and close connection.
# for passive stuff we must do this on thread basis
#
# For incoming from network request/reply we can call services in tpacall() way and wait for reply back with tpgetrply()
# Only this needs to be done with same thread which did the calls to services.
#
req_reply=True|False

#
# Timeout for doing request+reply (this is timeout to external system)
# For internal requests it is standard ATMI timeout
# in seconds...
#
req_reply_timeout = 60

#
# If we want request + reply over the persistent connections, then we need kind of message router which understands
# to which server do the reply.
# It will send back EX_GATEWAY_CORR  of the incoming message. If none is found in request registry, then message is sent to incoming_service.
# This is optional parameter. Thus every incoming message well be sent to this, incoming EX_GATEWAY_CORR from tpcall() will be
#  hashed with tpsrvgetctxdata(). When matching EX_GATEWAY_CORR is found, then tpsrvsetctxdata() is used, and tpreturn() is done.
# If EX_GATEWAY_RSPSVC  was set, then just tpcall() is done with response buffer to specified server.
corr_svc = <send the message with incoming buffer for correlator service>
